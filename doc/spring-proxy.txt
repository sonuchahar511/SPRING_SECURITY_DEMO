https://springframework.guru/gang-of-four-design-patterns/proxy-pattern/

https://spring.io/blog/2012/05/23/transactions-caching-and-aop-understanding-proxy-usage-in-spring

https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch08s06.html

https://spring.io/blog/2012/05/23/transactions-caching-and-aop-understanding-proxy-usage-in-spring

https://www.baeldung.com/spring-aop-vs-aspectj



Whenever we add extra functionality to the class like transaction management, caching etc in spring,
Spring creates a proxy class of that class and add the functionality in the proxy class.

Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object.
AOP:
    Aspect
    Joinpoint
    Advice
    Pointcut
    Weaving

EXAMPLE:
    Suppose you have autowired a dependency in controller of interface type
    e.g. AccountService has been autowired in AccountController but you haven't mentioned
    @Transactional annotation in AccountServiceImpl class which implements AccountService
    interface then Spring will simply inject AccountServiceImpl object in AccountController.
    And if @Transactional annotation is mentioned at AccountServiceImpl class then Spring will
    create a proxy object which will also implement AccountService interface and proxy object can be
    considered as wrapper of impl class. The generated proxy class comes on top of AccountServiceImpl.
    It adds Transactional behavior to it.
    This class is a Dynamic Proxy, generated by Spring using the JDK Reflection API.
    At shutdown (eg. When the application  is stopped), the proxy class will be destroyed and
    we will only have AccountService and AccountServiceImpl on the file system. This is called

    Configuration Required for adding Transactional behavior to class.
    <bean id="transactionManager">
     <property name="entityManagerFactory" ref="entityManagerFactory" />
    </bean>
    <tx:annotation-driven/> : It means that all @Transactional annotations should be scanned
    at startup time and the targeted methods should become transactional.

    If Our class hasn't implemented any interface then Spring creates child class to create a
    proxy object. but to do so it requires external dependency like cglib.
        There are some issues if CGLIB proxy model:
            final methods cannot be advised, as they cannot be overriden.
            cglib jar must be available in classpath.
            The constructor of your proxied object will be called twice.


        To force the use of CGLIB proxies set the value of the proxy-target-class attribute of
        the <aop:config> element to true:
            <aop:config proxy-target-class="true">
                <!-- other beans defined here... -->
            </aop:config>


        To force CGLIB proxying when using the @AspectJ autoproxy support, set the 'proxy-target-class'
        attribute of the <aop:aspectj-autoproxy> element to true:
            <aop:aspectj-autoproxy proxy-target-class="true"/>

        Multiple <aop:config/> sections are collapsed into a single unified auto-proxy creator at runtime,
        which applies the strongest proxy settings that any of the <aop:config/> sections (typically
        from different XML bean definition files) specified. This also applies to the
        <tx:annotation-driven/> and <aop:aspectj-autoproxy/> elements

        To be clear: using 'proxy-target-class="true"' on <tx:annotation-driven/>,
        <aop:aspectj-autoproxy/> or <aop:config/> elements will force the use of CGLIB proxies
        for all three of them.

    Spring-aop and aspects difference:
        Spring AOP aims to provide a simple AOP implementation across Spring IoC to solve
        the most common problems that programmers face. It is not intended as a complete AOP
        solution â€“ it can only be applied to beans that are managed by a Spring container.

        AspectJ is the original AOP technology which aims to provide complete AOP solution. It is more robust but
        also significantly more complicated than Spring AOP. It's also worth noting that AspectJ can
        be applied across all domain objects.

        AspectJ, on the other hand, doesn't do anything at runtime as the classes are compiled directly with aspects.
        And so unlike Spring AOP, it doesn't require any design patterns. To weave the aspects
        to the code, it introduces its compiler known as AspectJ compiler (ajc),
        through which we compile our program and then runs it by supplying a small (< 100K)
        runtime library.



